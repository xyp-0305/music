(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('xtemplate-runtime'), require('xtemplate-compiler')) :
  typeof define === 'function' && define.amd ? define(['exports', 'xtemplate-runtime', 'xtemplate-compiler'], factory) :
  (global = global || self, factory(global.XTemplate = {}, global.XTemplateRuntime, global.XTemplateCompiler));
}(this, function (exports, XTemplateRuntime, XTemplateCompiler) { 'use strict';

  XTemplateRuntime = XTemplateRuntime && XTemplateRuntime.hasOwnProperty('default') ? XTemplateRuntime['default'] : XTemplateRuntime;
  XTemplateCompiler = XTemplateCompiler && XTemplateCompiler.hasOwnProperty('default') ? XTemplateCompiler['default'] : XTemplateCompiler;

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var util = XTemplateRuntime.util;
  var _compile = XTemplateCompiler.compile;
  /**
   * xtemplate engine
   *
   *      @example
   *      modulex.use('xtemplate', function(XTemplate){
   *          document.writeln(new XTemplate('{{title}}').render({title:2}));
   *      });
   *
   * @class XTemplate
   * @extends XTemplate.Runtime
   */

  function XTemplate(tpl_, config_) {
    var tpl = tpl_;
    var config = config_;

    var tplType = _typeof(tpl);

    if (tplType !== 'string' && tplType !== 'function') {
      config = tpl;
      tpl = undefined;
    }

    config = this.config = util.merge(XTemplate.globalConfig, config);

    if (tplType === 'string') {
      try {
        tpl = this.compile(tpl, config.name);
      } catch (err) {
        this.compileError = err;
      }
    }

    XTemplateRuntime.call(this, tpl, config);
  }

  function Noop() {}

  Noop.prototype = XTemplateRuntime.prototype;
  XTemplate.prototype = new Noop();
  XTemplate.prototype.constructor = XTemplate;
  util.mix(XTemplate.prototype, {
    compile: function compile(content, name) {
      return _compile(content, name, this.config);
    },
    render: function render(data, option, callback_) {
      var callback = callback_;

      if (typeof option === 'function') {
        callback = option;
      }

      var compileError = this.compileError;

      if (compileError) {
        if (callback) {
          callback(compileError);
        } else {
          throw compileError;
        }
      } else {
        return XTemplateRuntime.prototype.render.apply(this, arguments);
      }
    }
  });
  var index = util.mix(XTemplate, {
    globalConfig: {},
    config: XTemplateRuntime.config,
    compile: _compile,
    Compiler: XTemplateCompiler,
    Scope: XTemplateRuntime.Scope,
    Runtime: XTemplateRuntime,

    /**
     * add command to all template
     * @method
     * @static
     * @param {String} commandName
     * @param {Function} fn
     */
    addCommand: XTemplateRuntime.addCommand,

    /**
     * remove command from all template by name
     * @method
     * @static
     * @param {String} commandName
     */
    removeCommand: XTemplateRuntime.removeCommand
  });
  /*
   It consists three modules:

   -   xtemplate - Both compiler and runtime functionality.
   -   xtemplate/compiler - Compiler string template to module functions.
   -   xtemplate/runtime -  Runtime for string template( with xtemplate/compiler loaded)
   or template functions.

   xtemplate/compiler depends on xtemplate/runtime,
   because compiler needs to know about runtime to generate corresponding codes.
   */

  exports.default = index;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
